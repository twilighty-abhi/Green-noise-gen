<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serene Sleep - Mindful Green Noise</title>
    <style>
        :root {
            /* Color palette inspired by nature and calm */
            --primary-hue: 140; /* Base green hue */
            --primary-color: hsl(var(--primary-hue), 40%, 45%); /* Deeper green */
            --secondary-color: hsl(var(--primary-hue), 35%, 60%); /* Softer green */
            --accent-color: hsl(60, 50%, 95%); /* Soft cream */
            --dark-color: hsl(var(--primary-hue), 20%, 15%); /* Deep muted green-grey */
            --light-color: hsl(var(--primary-hue), 25%, 85%); /* Light muted green */
            --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smooth transition */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background: linear-gradient(to bottom, hsl(var(--primary-hue), 20%, 10%), hsl(var(--primary-hue), 25%, 20%));
            color: var(--light-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            transition: background 1s ease; /* Smooth background transition */
            overflow: hidden; /* Hide scrollbars caused by large canvas */
        }

        .container {
            width: 100%;
            max-width: 500px;
            background-color: hsla(var(--primary-hue), 20%, 15%, 0.85); /* Semi-transparent dark */
            border-radius: 20px; /* Softer corners */
            padding: 30px 35px;
            box-shadow: 0 15px 40px hsla(0, 0%, 0%, 0.4);
            backdrop-filter: blur(15px);
            border: 1px solid hsla(var(--primary-hue), 25%, 30%, 0.5);
            transition: background-color 1s ease;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: var(--accent-color);
            font-weight: 300;
            font-size: 28px;
            letter-spacing: 1.5px;
        }

        .visualization {
            width: 100%;
            height: 220px; /* Increased height */
            border-radius: 15px;
            margin-bottom: 30px;
            overflow: hidden;
            position: relative;
            background: transparent; /* Canvas will handle background */
            border: 1px solid hsla(var(--primary-hue), 25%, 30%, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased gap */
        }

        .sound-options-label, .timer-section-label {
            font-size: 14px;
            color: var(--light-color);
            opacity: 0.7;
            margin-bottom: -15px; /* Position closer to buttons */
            text-align: center;
        }

        .sound-options {
            display: grid; /* Use grid for better alignment */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
        }

        .sound-options .btn, .timer-presets .timer-btn {
            font-size: 13px; /* Smaller font for more text */
            padding: 10px 5px; /* Adjust padding */
            background-color: hsla(var(--primary-hue), 25%, 30%, 0.5);
            color: var(--light-color);
            border: 1px solid transparent; /* Start transparent */
            border-radius: 10px;
            transition: var(--transition);
            cursor: pointer;
            text-align: center;
        }

        .sound-options .btn:hover, .timer-presets .timer-btn:hover {
            background-color: hsla(var(--primary-hue), 30%, 40%, 0.7);
            border-color: hsla(var(--primary-hue), 30%, 50%, 0.5);
        }

        .sound-options .btn.active, .timer-presets .timer-btn.active {
            background-color: var(--secondary-color);
            color: var(--dark-color);
            font-weight: 500;
            border-color: transparent;
            box-shadow: 0 2px 5px hsla(var(--primary-hue), 30%, 20%, 0.3);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .volume-icon {
            font-size: 22px; /* Slightly smaller */
            color: var(--secondary-color);
            width: 30px;
            text-align: center;
            opacity: 0.8;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px; /* Thinner slider */
            border-radius: 3px;
            background: hsla(var(--primary-hue), 25%, 30%, 0.6);
            outline: none;
            transition: var(--transition);
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            transition: var(--transition);
            border: none;
            box-shadow: 0 1px 3px hsla(0, 0%, 0%, 0.3);
        }

        .slider::-webkit-slider-thumb:hover {
            background: var(--primary-color);
            transform: scale(1.1);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            border: none;
            transition: var(--transition);
            box-shadow: 0 1px 3px hsla(0, 0%, 0%, 0.3);
        }

        .slider::-moz-range-thumb:hover {
            background: var(--primary-color);
            transform: scale(1.1);
        }

        .main-buttons {
            display: flex;
            justify-content: center;
            gap: 20px; /* Wider gap */
            margin-top: 10px;
        }

        .main-btn { /* Renamed from .btn to avoid conflict */
            background-color: var(--secondary-color);
            color: var(--dark-color);
            border: none;
            padding: 14px 35px; /* Larger buttons */
            border-radius: 30px; /* Fully rounded */
            cursor: pointer;
            font-size: 18px; /* Larger font */
            font-weight: 500;
            transition: var(--transition);
            min-width: 120px;
            text-align: center;
            box-shadow: 0 4px 10px hsla(var(--primary-hue), 30%, 20%, 0.3);
        }

        .main-btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-3px);
            box-shadow: 0 6px 15px hsla(var(--primary-hue), 30%, 20%, 0.4);
        }

        .main-btn.active {
            background-color: var(--accent-color);
            color: var(--primary-color);
            box-shadow: inset 0 2px 4px hsla(0, 0%, 0%, 0.1);
        }
        .main-btn#stopBtn.active {
             background-color: hsl(0, 40%, 60%); /* Subtle red hint for stop */
             color: var(--accent-color);
        }


        .timer-section {
            margin-top: 15px; /* Adjusted margin */
        }

        .timer-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Four columns */
            gap: 10px;
            margin-top: 10px; /* Reduced margin */
        }

        /* Timer presets button styling is shared with sound options */

        .timer-display {
            text-align: center;
            font-size: 20px; /* Slightly smaller */
            margin-top: 20px;
            color: var(--accent-color);
            font-weight: 300;
            letter-spacing: 1px;
            height: 30px; /* Adjusted height */
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .timer-display:empty {
            opacity: 0;
        }

        footer {
            margin-top: 30px;
            text-align: center;
            font-size: 13px;
            color: hsla(var(--primary-hue), 25%, 85%, 0.5);
            position: absolute;
            bottom: 15px;
            width: 100%;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }
             .sound-options {
                grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); /* Adjust minmax */
            }
            .main-btn {
                padding: 12px 25px;
                font-size: 16px;
            }
            h1 {
                font-size: 24px;
            }
            .visualization {
                height: 180px;
            }
        }
        @media (max-width: 400px) {
             .sound-options {
                grid-template-columns: repeat(2, 1fr); /* 2 columns on very small screens */
            }
            .timer-presets {
                grid-template-columns: repeat(2, 1fr); /* 2 columns */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Serene Sleep</h1>
        <div class="visualization">
            <canvas id="visualizer"></canvas>
        </div>
        <div class="controls">
             <div class="sound-options-label">Choose Ambiance</div>
            <div class="sound-options">
                <button class="btn active" data-sound="forest" data-hue="120">Forest Stream</button>
                <button class="btn" data-sound="waterfall" data-hue="200">Distant Fall</button>
                <button class="btn" data-sound="rain" data-hue="180">Gentle Rain</button>
                <button class="btn" data-sound="trees" data-hue="90">Rustling Trees</button>
                <button class="btn" data-sound="ocean" data-hue="210">Calm Waves</button>
                 <button class="btn" data-sound="ambient" data-hue="270">Deep Space</button> <!-- Added an ambient option -->
            </div>

            <div class="volume-control">
                <div class="volume-icon">🔊</div>
                <input type="range" min="0" max="1" step="0.01" value="0.4" class="slider" id="volume"> <!-- Default volume lower -->
            </div>

            <div class="main-buttons">
                <button class="main-btn" id="playBtn">Play</button>
                <button class="main-btn" id="stopBtn">Stop</button>
            </div>

            <div class="timer-section">
                 <div class="timer-section-label">Set Timer</div>
                <div class="timer-presets">
                    <!-- Updated timer presets -->
                    <button class="timer-btn" data-time="15">15 min</button>
                    <button class="timer-btn" data-time="30">30 min</button>
                    <button class="timer-btn" data-time="90">90 min</button>
                    <button class="timer-btn" data-time="180">3 hours</button>
                </div>
                <div class="timer-display" id="timerDisplay"></div>
            </div>
        </div>
    </div>
    <footer>
        <p>Mindful Green Noise • Drift into tranquility</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuration ---
            const PARTICLE_COUNT_FACTOR = 25; // Lower number means more particles (e.g., 20 for more, 30 for less)
            const BREATH_SPEED = 0.004; // Speed of the visual breath cycle (lower is slower)
            const FADE_OUT_DURATION = 10; // Seconds for audio fade out

            // --- State Variables ---
            let audioContext;
            let noiseNode;
            let gainNode;
            let analyser;
            let isPlaying = false;
            let timer = null;
            let remainingTime = 0;
            let timerInterval = null;
            let currentSound = 'forest';
            let targetHue = 120; // Default hue for Forest Stream
            let currentHue = 120; // Hue used for drawing, smoothly transitions to targetHue
            let breathProgress = 0; // 0 to 1 for a complete breath cycle (inhale + exhale)
            let particles = [];
            let animationFrameId;

            // --- DOM Elements ---
            const canvas = document.getElementById('visualizer');
            const canvasContext = canvas.getContext('2d');
            const volumeSlider = document.getElementById('volume');
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            const timerDisplay = document.getElementById('timerDisplay');
            const soundOptionBtns = document.querySelectorAll('.sound-options .btn');
            const timerPresetBtns = document.querySelectorAll('.timer-presets .timer-btn');
            const bodyElement = document.body;
            const containerElement = document.querySelector('.container');

            // --- Canvas & Particle Setup ---
            let width, height;

            function resizeCanvas() {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }
                createParticles(); // Recreate particles on resize
            }

            function createParticles() {
                particles = [];
                const particleCount = Math.max(10, Math.floor(width / PARTICLE_COUNT_FACTOR)); // Ensure at least a few particles
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: Math.random() * 2.5 + 1.5, // Slightly larger base size
                        opacity: Math.random() * 0.2 + 0.05, // Lower opacity
                        speedX: (Math.random() - 0.5) * 0.15, // Very slow drift
                        speedY: (Math.random() - 0.5) * 0.15,
                        hueOffset: Math.random() * 30 - 15, // More hue variation
                        phase: Math.random() * Math.PI * 2 // Random phase for movement
                    });
                }
            }

            // --- Audio Initialization and Control ---
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    gainNode = audioContext.createGain();
                    gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime); // Set initial volume correctly
                    gainNode.connect(audioContext.destination);

                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 512; // Smaller FFT size for potentially smoother analysis
                    analyser.smoothingTimeConstant = 0.9; // High smoothing
                    analyser.connect(gainNode);
                }
                 // Ensure context is running (especially after user interaction)
                 if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
            }

            function createSound(type) {
                if (!audioContext) initAudio(); // Ensure context exists

                // --- Noise Generation (Shared) ---
                const bufferSize = audioContext.sampleRate * 2; // 2 seconds of noise buffer
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); // Mono noise
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1; // White noise
                }

                const whiteNoiseSource = audioContext.createBufferSource();
                whiteNoiseSource.buffer = noiseBuffer;
                whiteNoiseSource.loop = true;

                // --- Filtering ---
                // Green noise focuses on mid frequencies (~500Hz - 4000Hz)
                // We use filters to shape the white noise.
                const lowShelf = audioContext.createBiquadFilter();
                lowShelf.type = 'lowshelf';

                const highShelf = audioContext.createBiquadFilter();
                highShelf.type = 'highshelf';

                const midPeak1 = audioContext.createBiquadFilter();
                midPeak1.type = 'peaking';

                const midPeak2 = audioContext.createBiquadFilter(); // Optional second peak for complexity
                midPeak2.type = 'peaking';


                // --- Filter Settings per Sound Type ---
                // These values shape the noise to mimic the descriptions
                let lsFreq = 500, lsGain = -15;
                let hsFreq = 4000, hsGain = -15;
                let p1Freq = 1500, p1Q = 1.0, p1Gain = 6;
                let p2Freq = 2500, p2Q = 1.5, p2Gain = 0; // Second peak off by default

                switch (type) {
                    case 'forest': // Forest Stream: Balanced mids, slightly lower focus
                        lsFreq = 400; lsGain = -12;
                        hsFreq = 4000; hsGain = -16;
                        p1Freq = 1200; p1Q = 0.8; p1Gain = 5;
                        p2Freq = 2200; p2Q = 1.2; p2Gain = 3; // Add subtle complexity
                        break;
                    case 'waterfall': // Distant Waterfall: Brighter, higher mids
                        lsFreq = 600; lsGain = -18;
                        hsFreq = 5500; hsGain = -10;
                        p1Freq = 2800; p1Q = 1.2; p1Gain = 8;
                        break;
                    case 'rain': // Gentle Rain: Softer, higher frequency focus
                        lsFreq = 800; lsGain = -20;
                        hsFreq = 6000; hsGain = -8;
                        p1Freq = 3500; p1Q = 1.5; p1Gain = 6;
                        break;
                    case 'trees': // Rustling Trees: Broader mid-range, less sharp
                        lsFreq = 300; lsGain = -16;
                        hsFreq = 3800; hsGain = -14;
                        p1Freq = 1800; p1Q = 0.7; p1Gain = 7;
                        break;
                    case 'ocean': // Calm Waves: Lower mids, softer feel
                        lsFreq = 250; lsGain = -10;
                        hsFreq = 3000; hsGain = -18;
                        p1Freq = 900; p1Q = 0.6; p1Gain = 4;
                        p2Freq = 1600; p2Q = 1.0; p2Gain = 2; // Add subtle wave character
                        break;
                    case 'ambient': // Deep Space: Very low-mid focus, smooth
                        lsFreq = 150; lsGain = -8;
                        hsFreq = 2500; hsGain = -20;
                        p1Freq = 600; p1Q = 0.5; p1Gain = 3;
                        break;
                }

                // Apply filter values
                lowShelf.frequency.setValueAtTime(lsFreq, audioContext.currentTime);
                lowShelf.gain.setValueAtTime(lsGain, audioContext.currentTime);
                highShelf.frequency.setValueAtTime(hsFreq, audioContext.currentTime);
                highShelf.gain.setValueAtTime(hsGain, audioContext.currentTime);
                midPeak1.frequency.setValueAtTime(p1Freq, audioContext.currentTime);
                midPeak1.Q.setValueAtTime(p1Q, audioContext.currentTime);
                midPeak1.gain.setValueAtTime(p1Gain, audioContext.currentTime);
                midPeak2.frequency.setValueAtTime(p2Freq, audioContext.currentTime);
                midPeak2.Q.setValueAtTime(p2Q, audioContext.currentTime);
                midPeak2.gain.setValueAtTime(p2Gain, audioContext.currentTime);

                // Connect the filter chain
                whiteNoiseSource.connect(lowShelf);
                lowShelf.connect(highShelf);
                highShelf.connect(midPeak1);
                midPeak1.connect(midPeak2); // Include second peak
                midPeak2.connect(analyser); // Connect final filter to analyser

                return whiteNoiseSource;
            }

            function playNoise() {
                if (isPlaying) return;
                initAudio(); // Ensure context is ready

                if (noiseNode) { // Clean up previous node if any (safety)
                    try { noiseNode.stop(); } catch (e) {}
                    noiseNode.disconnect();
                }

                noiseNode = createSound(currentSound);
                try {
                     noiseNode.start();
                     isPlaying = true;
                     playBtn.classList.add('active');
                     stopBtn.classList.remove('active');
                     startVisualization();
                } catch (error) {
                     console.error("Error starting audio:", error);
                     // Provide user feedback here if possible
                     isPlaying = false; // Reset state
                }
            }

            function stopNoise(fadeOut = false) {
                if (!isPlaying || !noiseNode) return;

                 if (fadeOut && gainNode) {
                    const currentVolume = gainNode.gain.value;
                    gainNode.gain.cancelScheduledValues(audioContext.currentTime); // Clear any previous fades
                    gainNode.gain.setValueAtTime(currentVolume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + FADE_OUT_DURATION); // Fade to near zero

                    // Stop the source node after the fade is complete
                     if(timer) clearTimeout(timer); // Clear the main timer if fading manually
                     timer = setTimeout(() => {
                        if (noiseNode) {
                           try { noiseNode.stop(); } catch(e) {}
                            noiseNode.disconnect();
                            noiseNode = null;
                         }
                         // Reset volume after fade for next play
                         if (gainNode) gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime);
                        completeStop(); // Finish the stop process
                    }, FADE_OUT_DURATION * 1000);

                } else {
                     // Immediate stop
                     try { noiseNode.stop(); } catch(e) {}
                     noiseNode.disconnect();
                     noiseNode = null;
                     if (gainNode) gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime); // Reset volume immediately
                     completeStop();
                 }
            }

             function completeStop() {
                 isPlaying = false;
                 stopVisualization();
                 playBtn.classList.remove('active');
                 stopBtn.classList.add('active'); // Indicate stop is active
                 clearTimer(); // Also clear timer display and active states
             }


            // --- Visualization ---
            function startVisualization() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId); // Prevent duplicates
                resizeCanvas(); // Ensure dimensions are correct
                visualize();
            }

            function stopVisualization() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                 // Optionally clear the canvas on stop
                // setTimeout(() => canvasContext.clearRect(0, 0, width, height), 100);
                 // Or fade it out
                 canvasContext.fillStyle = `hsla(var(--primary-hue), 20%, 15%, 0.1)`; // Fade effect
                 canvasContext.fillRect(0, 0, width, height);
            }

            function visualize() {
                if (!isPlaying && !document.hidden) { // Stop animation if not playing or tab hidden
                   // Keep drawing a static frame for a bit, then stop? Or stop immediately.
                   // stopVisualization(); // Option 1: Stop immediately
                   // return;           // Option 1
                }

                animationFrameId = requestAnimationFrame(visualize);

                 // Smoothly transition the current drawing hue towards the target hue
                 currentHue += (targetHue - currentHue) * 0.05; // Adjust 0.05 for faster/slower color transition

                 // Update body/container background HSL based on currentHue for cohesive feel
                 bodyElement.style.setProperty('--primary-hue', Math.round(currentHue));
                 containerElement.style.setProperty('--primary-hue', Math.round(currentHue));


                // --- Clear canvas with a soft gradient background ---
                const gradient = canvasContext.createRadialGradient(
                    width / 2, height / 2, 0,
                    width / 2, height / 2, Math.max(width, height) * 0.7
                );
                gradient.addColorStop(0, `hsla(${currentHue}, 50%, 20%, 0.8)`); // Center color
                gradient.addColorStop(1, `hsla(${currentHue}, 40%, 10%, 0.9)`); // Outer color
                canvasContext.fillStyle = gradient;
                canvasContext.fillRect(0, 0, width, height);

                // --- Update Breathing Cycle ---
                // Simple sine wave for smooth inhale/exhale transition
                breathCycle += BREATH_SPEED;
                breathProgress = (Math.sin(breathCycle) + 1) / 2; // Oscillates between 0 and 1

                // --- Draw Central Breathing Element ---
                const centerX = width / 2;
                const centerY = height / 2;
                const baseRadius = Math.min(width, height) * 0.1; // Smaller base
                const breathAmplitude = Math.min(width, height) * 0.08; // Amplitude of breath expansion
                const currentRadius = baseRadius + breathProgress * breathAmplitude;

                // Outer Glow
                const glowRadius = currentRadius * 2.5; // Larger, softer glow
                const glowGradient = canvasContext.createRadialGradient(
                    centerX, centerY, currentRadius * 0.5, // Start glow closer to center
                    centerX, centerY, glowRadius
                );
                glowGradient.addColorStop(0, `hsla(${currentHue}, 70%, 60%, 0.15)`); // Inner glow color
                glowGradient.addColorStop(0.5, `hsla(${currentHue}, 70%, 55%, 0.05)`);
                glowGradient.addColorStop(1, `hsla(${currentHue}, 60%, 50%, 0)`); // Fade out

                canvasContext.beginPath();
                canvasContext.arc(centerX, centerY, glowRadius, 0, Math.PI * 2);
                canvasContext.fillStyle = glowGradient;
                canvasContext.fill();

                // Inner Circle (subtle)
                canvasContext.beginPath();
                canvasContext.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
                canvasContext.fillStyle = `hsla(${currentHue}, 65%, 70%, 0.03)`; // Very subtle fill
                // canvasContext.lineWidth = 1; // Optional thin border
                // canvasContext.strokeStyle = `hsla(${currentHue}, 70%, 80%, 0.1)`;
                // canvasContext.stroke();
                canvasContext.fill();


                // --- Update and Draw Particles ---
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];

                    // Update position with drift + subtle breath influence
                    p.x += p.speedX;
                    p.y += p.speedY;

                     // Add slight circular motion based on phase
                    const angle = p.phase + breathCycle * 0.1; // Rotate slowly
                    p.x += Math.cos(angle) * 0.05;
                    p.y += Math.sin(angle) * 0.05;


                    // Gentle push/pull from center based on breath
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 0.1; // Avoid division by zero
                    const pushPullFactor = (breathProgress - 0.5) * 0.1 * (1 - Math.min(1, dist / (width * 0.4))); // Stronger effect near center
                    p.x += (dx / dist) * pushPullFactor;
                    p.y += (dy / dist) * pushPullFactor;


                    // Wrap around edges
                    if (p.x < -p.size) p.x = width + p.size;
                    if (p.x > width + p.size) p.x = -p.size;
                    if (p.y < -p.size) p.y = height + p.size;
                    if (p.y > height + p.size) p.y = -p.size;

                     // Calculate particle hue and opacity
                     const particleHue = (currentHue + p.hueOffset + 180) % 360; // Use complementary hue for contrast
                     const particleOpacity = p.opacity * (0.5 + breathProgress * 0.5); // Pulse opacity with breath

                    // Draw particle as a soft circle
                    canvasContext.beginPath();
                    canvasContext.arc(p.x, p.y, p.size, 0, Math.PI * 2);

                     // Soft gradient fill for particles
                     const particleGradient = canvasContext.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 1.5);
                     particleGradient.addColorStop(0, `hsla(${particleHue}, 60%, 80%, ${particleOpacity * 0.8})`);
                     particleGradient.addColorStop(1, `hsla(${particleHue}, 50%, 70%, 0)`);

                    canvasContext.fillStyle = particleGradient; // Use the gradient
                    canvasContext.fill();
                }
            }

            // --- Timer Logic ---
            function startTimer(minutes) {
                clearTimer(); // Clear previous timers first

                remainingTime = minutes * 60;
                updateTimerDisplay(); // Show initial time

                timerInterval = setInterval(updateTimerDisplay, 1000);

                timer = setTimeout(() => {
                    stopNoise(true); // Fade out when timer ends
                }, minutes * 60 * 1000);
            }

             function clearTimer() {
                 if (timer) clearTimeout(timer);
                 if (timerInterval) clearInterval(timerInterval);
                 timer = null;
                 timerInterval = null;
                 remainingTime = 0;
                 timerDisplay.textContent = '';
                 timerPresetBtns.forEach(btn => btn.classList.remove('active'));
             }

            function updateTimerDisplay() {
                if (remainingTime <= 0) {
                    clearTimer();
                    return;
                }

                const hours = Math.floor(remainingTime / 3600);
                const minutes = Math.floor((remainingTime % 3600) / 60);
                const seconds = remainingTime % 60;

                let displayText = '';
                if (hours > 0) {
                    displayText += `${hours}h `;
                }
                 // Always show minutes and seconds with padding
                displayText += `${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`;

                timerDisplay.textContent = displayText;
                remainingTime--;
            }

            // --- Event Listeners ---
            soundOptionBtns.forEach(button => {
                button.addEventListener('click', function() {
                    currentSound = this.dataset.sound;
                    targetHue = parseInt(this.dataset.hue, 10); // Update target hue

                    soundOptionBtns.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');

                    if (isPlaying) {
                        stopNoise(false); // Stop immediately
                        playNoise(); // Start new sound
                    }
                });
            });

            playBtn.addEventListener('click', playNoise);
            stopBtn.addEventListener('click', () => stopNoise(false)); // Immediate stop on button press

            volumeSlider.addEventListener('input', function() {
                if (gainNode && audioContext) { // Check if gainNode exists
                    // Use setTargetAtTime for slightly smoother volume changes
                     gainNode.gain.setTargetAtTime(this.value, audioContext.currentTime, 0.01);
                }
            });

            timerPresetBtns.forEach(button => {
                button.addEventListener('click', function() {
                    const minutes = parseInt(this.dataset.time);
                    if (!isNaN(minutes)) {
                        timerPresetBtns.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');
                        if (!isPlaying) playNoise(); // Start playing if not already
                        startTimer(minutes);
                    }
                });
            });

             // Handle visibility change to pause/resume animation (saves resources)
             document.addEventListener('visibilitychange', () => {
                 if (document.hidden) {
                     if (animationFrameId) {
                         cancelAnimationFrame(animationFrameId);
                         animationFrameId = null;
                     }
                 } else {
                     if (isPlaying && !animationFrameId) {
                         startVisualization(); // Resume animation if playing and was stopped
                     }
                 }
             });

            // --- Initial Setup ---
            resizeCanvas(); // Initial canvas sizing
            stopBtn.classList.add('active'); // Start with stop button visually active

        });
    </script>
</body>
</html>
