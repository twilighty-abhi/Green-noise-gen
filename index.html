<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Serene Sleep - Mindful Green Noise</title>
    <style>
        :root {
            /* Color palette inspired by nature and calm */
            --primary-hue: 140; /* Base green hue */
            --primary-color: hsl(var(--primary-hue), 40%, 45%); /* Deeper green */
            --secondary-color: hsl(var(--primary-hue), 35%, 60%); /* Softer green */
            --accent-color: hsl(60, 50%, 95%); /* Soft cream */
            --dark-color: hsl(var(--primary-hue), 20%, 15%); /* Deep muted green-grey */
            --light-color: hsl(var(--primary-hue), 25%, 85%); /* Light muted green */
            --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* Smooth transition */
            --mobile-padding: 15px;
            --desktop-padding: 35px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Disable blue tap highlight on mobile */
        }

        html, body {
            height: 100%; /* Ensure body takes full height */
            overflow: hidden; /* Prevent scrolling, especially on mobile */
        }

        body {
            background: linear-gradient(to bottom, hsl(var(--primary-hue), 20%, 10%), hsl(var(--primary-hue), 25%, 20%));
            color: var(--light-color);
            min-height: 100vh; /* Use min-height for flexibility */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center vertically */
            padding: var(--mobile-padding);
            transition: background 1s ease;
        }

        .container {
            width: 100%;
            max-width: 500px;
            background-color: hsla(var(--primary-hue), 20%, 15%, 0.85);
            border-radius: 20px;
            padding: 25px var(--mobile-padding); /* Mobile padding first */
            box-shadow: 0 10px 30px hsla(0, 0%, 0%, 0.4); /* Slightly softer shadow */
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px); /* Safari */
            border: 1px solid hsla(var(--primary-hue), 25%, 30%, 0.5);
            transition: background-color 1s ease, padding 0.3s ease;
            overflow-y: auto; /* Allow scrolling within container if needed on small heights */
            max-height: calc(100vh - 2 * var(--mobile-padding)); /* Limit container height */
        }

        h1 {
            text-align: center;
            margin-bottom: 20px; /* Reduced margin */
            color: var(--accent-color);
            font-weight: 300;
            font-size: 24px; /* Adjusted size */
            letter-spacing: 1.5px;
        }

        .visualization {
            width: 100%;
            /* Aspect ratio approach for height */
            aspect-ratio: 16 / 8; /* Adjust ratio as needed */
            max-height: 200px; /* Max height constraint */
            border-radius: 15px;
            margin-bottom: 25px; /* Adjusted margin */
            overflow: hidden;
            position: relative;
            background: transparent;
            border: 1px solid hsla(var(--primary-hue), 25%, 30%, 0.3);
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px; /* Adjusted gap */
        }

        .control-section-label {
            font-size: 13px; /* Smaller label */
            color: var(--light-color);
            opacity: 0.6;
            margin-bottom: -10px; /* Pull closer to controls */
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sound-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(95px, 1fr)); /* Flexible grid */
            gap: 8px; /* Reduced gap */
        }

        .sound-options .btn, .timer-presets .timer-btn {
            font-size: 12px; /* Further reduced size */
            padding: 9px 5px; /* Adjusted padding */
            background-color: hsla(var(--primary-hue), 25%, 30%, 0.5);
            color: var(--light-color);
            border: 1px solid transparent;
            border-radius: 8px; /* Slightly less rounded */
            transition: var(--transition);
            cursor: pointer;
            text-align: center;
            white-space: nowrap; /* Prevent wrapping */
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .sound-options .btn:hover, .timer-presets .timer-btn:hover {
            background-color: hsla(var(--primary-hue), 30%, 40%, 0.7);
            border-color: hsla(var(--primary-hue), 30%, 50%, 0.5);
        }

        .sound-options .btn.active, .timer-presets .timer-btn.active {
            background-color: var(--secondary-color);
            color: var(--dark-color);
            font-weight: 600; /* Bolder active state */
            border-color: transparent;
            box-shadow: 0 1px 4px hsla(var(--primary-hue), 30%, 20%, 0.2);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 12px; /* Reduced gap */
        }

        .volume-icon {
            font-size: 20px;
            color: var(--secondary-color);
            width: 25px;
            text-align: center;
            opacity: 0.8;
            flex-shrink: 0; /* Prevent icon shrinking */
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: hsla(var(--primary-hue), 25%, 30%, 0.6);
            outline: none;
            transition: background 0.3s ease;
            cursor: pointer;
        }
         .slider:hover {
             background: hsla(var(--primary-hue), 25%, 40%, 0.8);
         }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            transition: var(--transition);
            border: none;
            box-shadow: 0 1px 3px hsla(0, 0%, 0%, 0.3);
        }

        .slider::-webkit-slider-thumb:hover {
            background: var(--primary-color);
            transform: scale(1.15); /* Slightly larger hover */
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
            border: none;
            transition: var(--transition);
            box-shadow: 0 1px 3px hsla(0, 0%, 0%, 0.3);
        }

        .slider::-moz-range-thumb:hover {
            background: var(--primary-color);
            transform: scale(1.15);
        }

        .main-buttons {
            display: flex;
            justify-content: center;
            gap: 15px; /* Reduced gap */
            margin-top: 5px; /* Reduced margin */
        }

        .main-btn {
            background-color: var(--secondary-color);
            color: var(--dark-color);
            border: none;
            padding: 12px 30px; /* Adjusted padding */
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px; /* Adjusted size */
            font-weight: 500;
            transition: var(--transition);
            min-width: 100px; /* Adjusted min-width */
            text-align: center;
            box-shadow: 0 3px 8px hsla(var(--primary-hue), 30%, 20%, 0.3);
        }
        .main-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .main-btn:not(:disabled):hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px hsla(var(--primary-hue), 30%, 20%, 0.4);
        }

        .main-btn.active:not(:disabled) {
            transform: translateY(1px); /* Press effect */
            box-shadow: inset 0 2px 4px hsla(0, 0%, 0%, 0.15);
        }

        .main-btn#playBtn.active:not(:disabled) {
             background-color: var(--accent-color);
             color: var(--primary-color);
        }
         .main-btn#stopBtn.active:not(:disabled) {
             background-color: hsl(0, 40%, 60%); /* Subtle red hint for stop */
             color: var(--accent-color);
         }


        .timer-section {
            margin-top: 10px; /* Adjusted margin */
        }

        .timer-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Four columns */
            gap: 8px; /* Reduced gap */
            margin-top: 5px; /* Reduced margin */
        }

        .timer-display {
            text-align: center;
            font-size: 18px; /* Adjusted size */
            margin-top: 15px; /* Adjusted margin */
            color: var(--accent-color);
            font-weight: 300;
            letter-spacing: 1px;
            height: 25px; /* Adjusted height */
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s ease;
            line-height: 25px; /* Match height */
        }

        .timer-display.visible {
             opacity: 0.8; /* Fade in when active */
        }


        footer {
             /* Removed fixed positioning for better flow */
            padding: 15px 0 5px 0; /* Add padding */
            text-align: center;
            font-size: 12px;
            color: hsla(var(--primary-hue), 25%, 85%, 0.5);
            width: 100%;
        }

        /* --- Responsive Adjustments --- */
        @media (min-width: 600px) {
             body {
                 padding: 20px; /* More padding on larger screens */
             }
             .container {
                padding: 30px var(--desktop-padding);
                max-height: calc(100vh - 40px);
             }
             h1 {
                 font-size: 28px;
                 margin-bottom: 30px;
             }
             .visualization {
                 aspect-ratio: 16 / 7; /* Adjust aspect ratio */
                 max-height: 220px;
                 margin-bottom: 30px;
             }
             .controls {
                 gap: 25px;
             }
             .control-section-label {
                 font-size: 14px;
                 margin-bottom: -15px;
             }
             .sound-options {
                 gap: 10px;
             }
             .sound-options .btn, .timer-presets .timer-btn {
                 font-size: 13px;
                 padding: 10px 5px;
             }
              .volume-control {
                 gap: 15px;
             }
              .volume-icon {
                 font-size: 22px;
                 width: 30px;
             }
             .main-buttons {
                 gap: 20px;
                 margin-top: 10px;
             }
             .main-btn {
                 padding: 14px 35px;
                 font-size: 18px;
                 min-width: 120px;
             }
             .timer-presets {
                 gap: 10px;
                 margin-top: 10px;
             }
             .timer-display {
                 font-size: 20px;
                 margin-top: 20px;
                 height: 30px;
                 line-height: 30px;
             }
              footer {
                 font-size: 13px;
             }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Serene Sleep</h1>
        <div class="visualization">
            <canvas id="visualizer"></canvas>
        </div>
        <div class="controls">
             <div class="control-section-label">Choose Ambiance</div>
            <div class="sound-options">
                <button class="btn active" data-sound="forest" data-hue="120">Forest Stream</button>
                <button class="btn" data-sound="waterfall" data-hue="200">Distant Fall</button>
                <button class="btn" data-sound="rain" data-hue="180">Gentle Rain</button>
                <button class="btn" data-sound="trees" data-hue="90">Rustling Trees</button>
                <button class="btn" data-sound="ocean" data-hue="210">Calm Waves</button>
                 <button class="btn" data-sound="ambient" data-hue="270">Deep Space</button>
            </div>

            <div class="volume-control">
                <div class="volume-icon">🔊</div>
                <input type="range" min="0" max="1" step="0.01" value="0.4" class="slider" id="volume" aria-label="Volume">
            </div>

            <div class="main-buttons">
                <button class="main-btn" id="playBtn">Play</button>
                <button class="main-btn" id="stopBtn">Stop</button>
            </div>

            <div class="timer-section">
                 <div class="control-section-label">Set Timer</div>
                <div class="timer-presets">
                    <button class="timer-btn" data-time="15">15 min</button>
                    <button class="timer-btn" data-time="30">30 min</button>
                    <button class="timer-btn" data-time="90">90 min</button>
                    <button class="timer-btn" data-time="180">3 hours</button>
                </div>
                <div class="timer-display" id="timerDisplay"></div>
            </div>
             <footer>
                <p>Mindful Green Noise • Drift into tranquility</p>
            </footer>
        </div> <!-- .controls end -->
    </div> <!-- .container end -->


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Configuration ---
            const PARTICLE_COUNT_FACTOR = 25;
            const BREATH_SPEED = 0.004;
            const FADE_OUT_DURATION = 8; // Faster fade out

            // --- State Variables ---
            let audioContext = null;
            let noiseNode = null;
            let gainNode = null;
            let analyser = null; // Keep analyser setup if needed later
            let isPlaying = false;
            let isStopping = false; // Flag to prevent rapid stop/start issues
            let timerTimeoutId = null;
            let remainingTime = 0;
            let timerIntervalId = null;
            let currentSound = 'forest';
            let targetHue = 120;
            let currentHue = 120;
            let breathCycle = Math.random() * Math.PI * 2; // Start breath at random phase
            let particles = [];
            let animationFrameId = null;
            let firstInteraction = false; // Track first user interaction for audio context

            // --- DOM Elements ---
            const canvas = document.getElementById('visualizer');
            const canvasContext = canvas.getContext('2d');
            const volumeSlider = document.getElementById('volume');
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            const timerDisplay = document.getElementById('timerDisplay');
            const soundOptionBtns = document.querySelectorAll('.sound-options .btn');
            const timerPresetBtns = document.querySelectorAll('.timer-presets .timer-btn');
            const bodyElement = document.body;
            const containerElement = document.querySelector('.container');

            // --- Canvas & Particle Setup ---
            let width, height;

            function resizeCanvas() {
                width = canvas.clientWidth;
                height = canvas.clientHeight;
                if (canvas.width !== width || canvas.height !== height) {
                    canvas.width = width;
                    canvas.height = height;
                }
                // Only create particles if width/height are valid
                if (width > 0 && height > 0) {
                     createParticles();
                }
            }

            function createParticles() {
                particles = [];
                if (!width || !height) return; // Don't create if canvas size is 0
                const particleCount = Math.max(10, Math.floor(width / PARTICLE_COUNT_FACTOR));
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: Math.random() * 2.5 + 1.5,
                        opacity: Math.random() * 0.2 + 0.05,
                        speedX: (Math.random() - 0.5) * 0.15,
                        speedY: (Math.random() - 0.5) * 0.15,
                        hueOffset: Math.random() * 30 - 15,
                        phase: Math.random() * Math.PI * 2
                    });
                }
            }

            // --- Audio Initialization and Control ---
            async function initAudio() {
                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();

                        // Check if context is suspended and resume if needed (especially on first interaction)
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }

                        gainNode = audioContext.createGain();
                        gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime);
                        gainNode.connect(audioContext.destination);

                        analyser = audioContext.createAnalyser();
                        analyser.fftSize = 512;
                        analyser.smoothingTimeConstant = 0.9;
                        // We connect the final sound node to analyser later
                        analyser.connect(gainNode); // Connect analyser to gain for potential future use

                        console.log("AudioContext initialized successfully. State:", audioContext.state);
                        firstInteraction = true; // Mark that interaction happened
                    } catch (e) {
                        console.error("Error initializing AudioContext:", e);
                        alert("Could not initialize audio. Your browser might not support it or permissions are denied.");
                        audioContext = null; // Ensure it's null if failed
                    }
                } else if (audioContext.state === 'suspended') {
                     try {
                         await audioContext.resume();
                         console.log("AudioContext resumed. State:", audioContext.state);
                     } catch (e) {
                         console.error("Error resuming AudioContext:", e);
                     }
                }
                 return audioContext !== null; // Return success status
            }

            function createSoundNode(type) {
                if (!audioContext) return null;

                const bufferSize = audioContext.sampleRate * 2;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }

                const sourceNode = audioContext.createBufferSource();
                sourceNode.buffer = noiseBuffer;
                sourceNode.loop = true;

                const lowShelf = audioContext.createBiquadFilter(); lowShelf.type = 'lowshelf';
                const highShelf = audioContext.createBiquadFilter(); highShelf.type = 'highshelf';
                const midPeak1 = audioContext.createBiquadFilter(); midPeak1.type = 'peaking';
                const midPeak2 = audioContext.createBiquadFilter(); midPeak2.type = 'peaking';

                let lsFreq = 500, lsGain = -15;
                let hsFreq = 4000, hsGain = -15;
                let p1Freq = 1500, p1Q = 1.0, p1Gain = 6;
                let p2Freq = 2500, p2Q = 1.5, p2Gain = 0;

                 switch (type) {
                    case 'forest': lsFreq = 400; lsGain = -12; hsFreq = 4000; hsGain = -16; p1Freq = 1200; p1Q = 0.8; p1Gain = 5; p2Freq = 2200; p2Q = 1.2; p2Gain = 3; break;
                    case 'waterfall': lsFreq = 600; lsGain = -18; hsFreq = 5500; hsGain = -10; p1Freq = 2800; p1Q = 1.2; p1Gain = 8; break;
                    case 'rain': lsFreq = 800; lsGain = -20; hsFreq = 6000; hsGain = -8; p1Freq = 3500; p1Q = 1.5; p1Gain = 6; break;
                    case 'trees': lsFreq = 300; lsGain = -16; hsFreq = 3800; hsGain = -14; p1Freq = 1800; p1Q = 0.7; p1Gain = 7; break;
                    case 'ocean': lsFreq = 250; lsGain = -10; hsFreq = 3000; hsGain = -18; p1Freq = 900; p1Q = 0.6; p1Gain = 4; p2Freq = 1600; p2Q = 1.0; p2Gain = 2; break;
                    case 'ambient': lsFreq = 150; lsGain = -8; hsFreq = 2500; hsGain = -20; p1Freq = 600; p1Q = 0.5; p1Gain = 3; break;
                }

                const now = audioContext.currentTime;
                lowShelf.frequency.setValueAtTime(lsFreq, now); lowShelf.gain.setValueAtTime(lsGain, now);
                highShelf.frequency.setValueAtTime(hsFreq, now); highShelf.gain.setValueAtTime(hsGain, now);
                midPeak1.frequency.setValueAtTime(p1Freq, now); midPeak1.Q.setValueAtTime(p1Q, now); midPeak1.gain.setValueAtTime(p1Gain, now);
                midPeak2.frequency.setValueAtTime(p2Freq, now); midPeak2.Q.setValueAtTime(p2Q, now); midPeak2.gain.setValueAtTime(p2Gain, now);

                // Connect chain: source -> filters -> analyser -> gain -> destination
                sourceNode.connect(lowShelf);
                lowShelf.connect(highShelf);
                highShelf.connect(midPeak1);
                midPeak1.connect(midPeak2);
                midPeak2.connect(analyser); // Connect final filter to analyser

                return sourceNode; // Return only the source node, it's connected internally
            }

            async function playCurrentSound() {
                 if (isPlaying || isStopping) return; // Prevent starting if already playing or currently stopping
                 console.log("Attempting to play...");

                 const audioReady = await initAudio(); // Ensure audio context is ready and resumed
                 if (!audioReady) {
                     console.error("Audio context not ready, cannot play.");
                     return;
                 }

                 // Stop any previous node cleanly before creating a new one
                 if (noiseNode) {
                     try {
                         noiseNode.stop();
                         noiseNode.disconnect(); // Disconnect all connections
                     } catch (e) { console.warn("Error stopping previous node:", e); }
                     noiseNode = null;
                 }

                 noiseNode = createSoundNode(currentSound);

                 if (!noiseNode) {
                     console.error("Failed to create sound node.");
                     return;
                 }

                 try {
                     gainNode.gain.cancelScheduledValues(audioContext.currentTime); // Cancel any pending fades
                     gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime); // Ensure volume is set

                     noiseNode.start();
                     isPlaying = true;
                     playBtn.classList.add('active');
                     stopBtn.classList.remove('active');
                     playBtn.disabled = true; // Disable play while playing
                     stopBtn.disabled = false;
                     startVisualization();
                     console.log("Playback started.");
                 } catch (error) {
                     console.error("Error starting audio playback:", error);
                     isPlaying = false; // Reset state on error
                     playBtn.disabled = false;
                     stopBtn.disabled = true;
                 }
            }

             function stopPlayback(fadeOut = false) {
                 if (!isPlaying || isStopping) return; // Prevent stopping if not playing or already stopping
                 console.log(`Attempting to stop playback (fade: ${fadeOut})`);
                 isStopping = true; // Set flag to prevent overlap
                 stopBtn.disabled = true; // Disable stop during the process

                 clearTimer(false); // Clear timer logic, but don't update UI yet

                 if (fadeOut && gainNode && audioContext) {
                     const now = audioContext.currentTime;
                     const currentVolume = gainNode.gain.value;
                     gainNode.gain.cancelScheduledValues(now);
                     gainNode.gain.setValueAtTime(currentVolume, now);
                     gainNode.gain.exponentialRampToValueAtTime(0.0001, now + FADE_OUT_DURATION);

                     // Use a timeout matching the fade duration to fully stop
                     setTimeout(() => {
                         finalizeStop();
                     }, FADE_OUT_DURATION * 1000);

                 } else {
                     finalizeStop(); // Stop immediately
                 }
             }

             function finalizeStop() {
                 console.log("Finalizing stop.");
                 if (noiseNode) {
                     try {
                         noiseNode.stop();
                         noiseNode.disconnect();
                     } catch (e) { console.warn("Error stopping node:", e); }
                     noiseNode = null;
                 }
                  // Reset gain immediately AFTER stopping the node
                  if (gainNode && audioContext) {
                      gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                      gainNode.gain.setValueAtTime(volumeSlider.value, audioContext.currentTime);
                  }

                 isPlaying = false;
                 isStopping = false; // Reset stopping flag
                 stopVisualization();
                 playBtn.classList.remove('active');
                 stopBtn.classList.add('active');
                 playBtn.disabled = false; // Re-enable play
                 stopBtn.disabled = true; // Disable stop
                 clearTimerDisplayAndButtons(); // Update timer UI now
                 console.log("Playback stopped.");
             }

            // --- Visualization ---
            function startVisualization() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId); // Ensure no duplicates
                resizeCanvas(); // Ensure dimensions are correct before first draw
                if (width > 0 && height > 0) { // Only start if canvas has size
                     console.log("Starting visualization...");
                     animationFrameId = requestAnimationFrame(visualize);
                } else {
                    console.warn("Canvas has no dimensions, cannot start visualization.");
                }
            }

            function stopVisualization() {
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                     console.log("Visualization stopped.");
                     // Optional: Clear canvas with a fade effect
                     if (canvasContext && width > 0 && height > 0) {
                        canvasContext.fillStyle = `hsla(${currentHue}, 20%, 15%, 0.5)`;
                        canvasContext.fillRect(0, 0, width, height);
                     }
                 }
             }


            function visualize() {
                // Important: Request next frame *early* in the function
                animationFrameId = requestAnimationFrame(visualize);

                if (!width || !height) return; // Skip drawing if canvas has no size

                // Smoothly transition the current drawing hue towards the target hue
                currentHue += (targetHue - currentHue) * 0.05;

                // Update body/container background HSL based on currentHue
                bodyElement.style.setProperty('--primary-hue', Math.round(currentHue));
                containerElement.style.setProperty('--primary-hue', Math.round(currentHue));

                // Clear canvas with a soft radial gradient background
                const gradient = canvasContext.createRadialGradient(
                    width / 2, height / 2, 0,
                    width / 2, height / 2, Math.max(width, height) * 0.7
                );
                gradient.addColorStop(0, `hsla(${currentHue}, 50%, 20%, 0.8)`);
                gradient.addColorStop(1, `hsla(${currentHue}, 40%, 10%, 0.9)`);
                canvasContext.fillStyle = gradient;
                canvasContext.fillRect(0, 0, width, height);

                // Update Breathing Cycle
                breathCycle += BREATH_SPEED;
                breathProgress = (Math.sin(breathCycle) + 1) / 2; // 0 to 1 oscillation

                // Draw Central Breathing Element
                const centerX = width / 2;
                const centerY = height / 2;
                const baseRadius = Math.min(width, height) * 0.1;
                const breathAmplitude = Math.min(width, height) * 0.08;
                const currentRadius = baseRadius + breathProgress * breathAmplitude;

                // Outer Glow
                const glowRadius = currentRadius * 2.5;
                const glowGradient = canvasContext.createRadialGradient(
                    centerX, centerY, currentRadius * 0.5,
                    centerX, centerY, glowRadius
                );
                glowGradient.addColorStop(0, `hsla(${currentHue}, 70%, 60%, 0.15)`);
                glowGradient.addColorStop(0.5, `hsla(${currentHue}, 70%, 55%, 0.05)`);
                glowGradient.addColorStop(1, `hsla(${currentHue}, 60%, 50%, 0)`);
                canvasContext.beginPath();
                canvasContext.arc(centerX, centerY, glowRadius, 0, Math.PI * 2);
                canvasContext.fillStyle = glowGradient;
                canvasContext.fill();

                // Update and Draw Particles
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];

                    // Update position
                    p.x += p.speedX;
                    p.y += p.speedY;
                    const angle = p.phase + breathCycle * 0.1;
                    p.x += Math.cos(angle) * 0.05;
                    p.y += Math.sin(angle) * 0.05;

                    // Gentle push/pull
                    const dx = p.x - centerX;
                    const dy = p.y - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
                    const pushPullFactor = (breathProgress - 0.5) * 0.1 * (1 - Math.min(1, dist / (width * 0.4)));
                    p.x += (dx / dist) * pushPullFactor;
                    p.y += (dy / dist) * pushPullFactor;

                    // Wrap around edges
                    if (p.x < -p.size) p.x = width + p.size;
                    if (p.x > width + p.size) p.x = -p.size;
                    if (p.y < -p.size) p.y = height + p.size;
                    if (p.y > height + p.size) p.y = -p.size;

                    // Calculate particle appearance
                    const particleHue = (currentHue + p.hueOffset + 180) % 360;
                    const particleOpacity = p.opacity * (0.5 + breathProgress * 0.5);

                    // Draw particle
                    canvasContext.beginPath();
                    canvasContext.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    const particleGradient = canvasContext.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 1.5);
                    particleGradient.addColorStop(0, `hsla(${particleHue}, 60%, 80%, ${particleOpacity * 0.8})`);
                    particleGradient.addColorStop(1, `hsla(${particleHue}, 50%, 70%, 0)`);
                    canvasContext.fillStyle = particleGradient;
                    canvasContext.fill();
                }
            }


            // --- Timer Logic ---
            function startTimer(minutes) {
                clearTimer(false); // Clear previous timers without UI update yet

                remainingTime = minutes * 60;
                updateTimerDisplay(); // Show initial time and make visible
                timerDisplay.classList.add('visible');

                timerIntervalId = setInterval(updateTimerDisplay, 1000);

                timerTimeoutId = setTimeout(() => {
                    console.log("Timer finished.");
                    stopPlayback(true); // Fade out when timer ends
                }, minutes * 60 * 1000);
                 console.log(`Timer started for ${minutes} minutes.`);
            }

             function clearTimer(updateUI = true) {
                 if (timerTimeoutId) clearTimeout(timerTimeoutId);
                 if (timerIntervalId) clearInterval(timerIntervalId);
                 timerTimeoutId = null;
                 timerIntervalId = null;
                 remainingTime = 0;
                 if(updateUI) {
                    clearTimerDisplayAndButtons();
                 }
                 console.log("Timer cleared.");
             }

             function clearTimerDisplayAndButtons() {
                  timerDisplay.textContent = '';
                  timerDisplay.classList.remove('visible');
                  timerPresetBtns.forEach(btn => btn.classList.remove('active'));
             }

            function updateTimerDisplay() {
                if (remainingTime <= 0) {
                    clearTimer(); // This will also clear interval and timeout
                    return;
                }

                const hours = Math.floor(remainingTime / 3600);
                const minutes = Math.floor((remainingTime % 3600) / 60);
                const seconds = remainingTime % 60;

                let displayText = '';
                if (hours > 0) displayText += `${hours}h `;
                displayText += `${minutes.toString().padStart(2, '0')}m ${seconds.toString().padStart(2, '0')}s`;

                timerDisplay.textContent = displayText;
                remainingTime--;
            }

            // --- Event Listeners ---
            soundOptionBtns.forEach(button => {
                button.addEventListener('click', async function() {
                     if (isStopping) return; // Prevent changes while stopping

                     // If audio context doesn't exist yet, init it on first sound click
                     if (!audioContext) {
                         const success = await initAudio();
                         if (!success) return; // Stop if audio init failed
                     }

                     const selectedSound = this.dataset.sound;
                     const selectedHue = parseInt(this.dataset.hue, 10);

                     if (currentSound === selectedSound && isPlaying) return; // Do nothing if clicking the active playing sound

                     console.log(`Sound selected: ${selectedSound}`);

                     currentSound = selectedSound;
                     targetHue = selectedHue;

                     soundOptionBtns.forEach(btn => btn.classList.remove('active'));
                     this.classList.add('active');

                     // Always play the newly selected sound
                     if (isPlaying) {
                        stopPlayback(false); // Stop current immediately
                        // Use a small delay to ensure the stop completes before starting new sound
                         setTimeout(playCurrentSound, 50);
                     } else {
                         playCurrentSound(); // Start playing if wasn't already
                     }
                });
            });

            playBtn.addEventListener('click', playCurrentSound);
            stopBtn.addEventListener('click', () => stopPlayback(false)); // Immediate stop

            volumeSlider.addEventListener('input', function() {
                if (gainNode && audioContext) {
                    gainNode.gain.setTargetAtTime(this.value, audioContext.currentTime, 0.015); // Smooth volume change
                }
            });

            timerPresetBtns.forEach(button => {
                button.addEventListener('click', async function() {
                    if (isStopping) return; // Prevent changes while stopping

                    const minutes = parseInt(this.dataset.time);
                    if (!isNaN(minutes)) {
                        timerPresetBtns.forEach(btn => btn.classList.remove('active'));
                        this.classList.add('active');

                         // If audio context doesn't exist yet, init it on first timer click
                        if (!audioContext) {
                             const success = await initAudio();
                             if (!success) return; // Stop if audio init failed
                         }

                        // Start playing if not already, then set timer
                        if (!isPlaying) {
                            await playCurrentSound(); // Ensure playback starts before timer
                        }
                         // Only start timer if playback is actually running or just started successfully
                        if (isPlaying) {
                             startTimer(minutes);
                        } else {
                            console.warn("Playback did not start, timer not set.");
                            clearTimerDisplayAndButtons(); // Ensure timer UI is cleared if play failed
                        }
                    }
                });
            });

             // Handle visibility change
             document.addEventListener('visibilitychange', () => {
                 if (document.hidden) {
                     // Pause animation when tab is hidden
                     if (animationFrameId) {
                         cancelAnimationFrame(animationFrameId);
                         animationFrameId = null;
                         console.log("Visualization paused due to tab hidden.");
                     }
                 } else {
                     // Resume animation only if playing and animation was stopped
                     if (isPlaying && !animationFrameId) {
                         startVisualization();
                         console.log("Visualization resumed due to tab visible.");
                     }
                 }
             });

             // Handle window resize
             let resizeTimeout;
             window.addEventListener('resize', () => {
                 clearTimeout(resizeTimeout);
                 resizeTimeout = setTimeout(() => {
                      console.log("Window resized");
                      resizeCanvas();
                       // If playing, restart visualization to adapt to new size
                      if (isPlaying && animationFrameId) {
                           cancelAnimationFrame(animationFrameId); // Stop old loop
                           animationFrameId = null;
                      }
                       if (isPlaying && !animationFrameId) {
                          startVisualization(); // Start new loop with correct dimensions
                       }
                 }, 250); // Debounce resize event
             });


            // --- Initial Setup ---
            resizeCanvas(); // Initial canvas sizing
            stopBtn.disabled = true; // Start with stop disabled
            playBtn.disabled = false;
            stopBtn.classList.add('active'); // Start with stop visually active

             // Add a listener to init audio on *any* first click/touch for mobile compatibility
             function handleFirstInteraction() {
                if (!firstInteraction) {
                    console.log("First user interaction detected.");
                    initAudio().then(success => {
                        if (success) {
                             // Maybe enable play button explicitly here if needed
                        }
                     });
                     // Remove this listener after first interaction
                     document.removeEventListener('click', handleFirstInteraction, true);
                     document.removeEventListener('touchstart', handleFirstInteraction, true);
                 }
             }
             document.addEventListener('click', handleFirstInteraction, true);
             document.addEventListener('touchstart', handleFirstInteraction, true);


            console.log("Green Noise App Initialized.");

        }); // End DOMContentLoaded
    </script>
</body>
</html>
